<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤§é‡å†å²è®°å½•å¤‡ä»½æµ‹è¯• - Mimir</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-section {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .test-button:hover {
            background: #2980b9;
        }
        .test-button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }
        .test-button.success {
            background: #27ae60;
        }
        .test-button.warning {
            background: #f39c12;
        }
        .test-button.error {
            background: #e74c3c;
        }
        .test-results {
            background: #f8f9fa;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            border-left: 4px solid #3498db;
            font-family: monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-indicator.success { background: #27ae60; }
        .status-indicator.error { background: #e74c3c; }
        .status-indicator.warning { background: #f39c12; }
        .status-indicator.info { background: #3498db; }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: #3498db;
            transition: width 0.3s ease;
            border-radius: 10px;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        .stat-card {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
        }
        .stat-label {
            font-size: 12px;
            color: #7f8c8d;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <h1>å¤§é‡å†å²è®°å½•å¤‡ä»½æµ‹è¯•</h1>
    <p>ä¸“é—¨æµ‹è¯•å¤„ç†å¤§é‡å†å²è®°å½•ï¼ˆå¦‚æ‚¨çš„10793æ¡ï¼‰çš„å¤‡ä»½åŠŸèƒ½</p>

    <!-- å†å²è®°å½•ç»Ÿè®¡ -->
    <div class="test-section">
        <h2>ğŸ“Š å†å²è®°å½•ç»Ÿè®¡</h2>
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-number" id="browserHistoryCount">-</div>
                <div class="stat-label">æµè§ˆå™¨å†å²è®°å½•</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="backedUpCount">-</div>
                <div class="stat-label">å·²å¤‡ä»½è®°å½•</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="coveragePercent">-</div>
                <div class="stat-label">å¤‡ä»½è¦†ç›–ç‡</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="missingCount">-</div>
                <div class="stat-label">æœªå¤‡ä»½è®°å½•</div>
            </div>
        </div>
        
        <button class="test-button" onclick="checkHistoryStats()">ğŸ” æ£€æŸ¥å†å²è®°å½•ç»Ÿè®¡</button>
        <button class="test-button" onclick="analyzeHistoryGaps()">ğŸ“ˆ åˆ†æå¤‡ä»½ç¼ºå£</button>
        
        <div id="statsResults" class="test-results"></div>
    </div>

    <!-- å¤‡ä»½åŠŸèƒ½æµ‹è¯• -->
    <div class="test-section">
        <h2>ğŸ’¾ å¤‡ä»½åŠŸèƒ½æµ‹è¯•</h2>
        <p>æµ‹è¯•ä¸åŒç±»å‹çš„å¤‡ä»½åŠŸèƒ½ï¼š</p>
        
        <div class="progress-bar" style="display: none;" id="backupProgress">
            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
        </div>
        <div id="progressText" style="text-align: center; margin: 10px 0; display: none;"></div>
        
        <button class="test-button" onclick="testIncrementalBackup()" id="incrementalBtn">
            ğŸ’¾ æµ‹è¯•å¢é‡å¤‡ä»½
        </button>
        <button class="test-button warning" onclick="testFullBackup()" id="fullBackupBtn">
            ğŸ”„ æµ‹è¯•å®Œæ•´å¤‡ä»½ï¼ˆæ…ç”¨ï¼‰
        </button>
        <button class="test-button" onclick="testBackupStatus()">
            ğŸ“Š æ£€æŸ¥å¤‡ä»½çŠ¶æ€
        </button>
        
        <div id="backupResults" class="test-results"></div>
    </div>

    <!-- æ€§èƒ½æµ‹è¯• -->
    <div class="test-section">
        <h2>âš¡ æ€§èƒ½æµ‹è¯•</h2>
        <p>æµ‹è¯•å¤§é‡æ•°æ®çš„å¤„ç†æ€§èƒ½ï¼š</p>
        
        <button class="test-button" onclick="testBatchProcessing()">ğŸš€ æµ‹è¯•æ‰¹é‡å¤„ç†æ€§èƒ½</button>
        <button class="test-button" onclick="testDatabaseQuery()">ğŸ” æµ‹è¯•æ•°æ®åº“æŸ¥è¯¢æ€§èƒ½</button>
        <button class="test-button" onclick="testMemoryUsage()">ğŸ’¾ æµ‹è¯•å†…å­˜ä½¿ç”¨æƒ…å†µ</button>
        
        <div id="performanceResults" class="test-results"></div>
    </div>

    <!-- æ•°æ®éªŒè¯ -->
    <div class="test-section">
        <h2>âœ… æ•°æ®éªŒè¯</h2>
        <p>éªŒè¯å¤‡ä»½æ•°æ®çš„å®Œæ•´æ€§å’Œå‡†ç¡®æ€§ï¼š</p>
        
        <button class="test-button" onclick="validateBackupData()">ğŸ” éªŒè¯å¤‡ä»½æ•°æ®å®Œæ•´æ€§</button>
        <button class="test-button" onclick="compareWithBrowser()">ğŸ“Š ä¸æµè§ˆå™¨æ•°æ®å¯¹æ¯”</button>
        <button class="test-button" onclick="checkDataConsistency()">âœ… æ£€æŸ¥æ•°æ®ä¸€è‡´æ€§</button>
        
        <div id="validationResults" class="test-results"></div>
    </div>

    <!-- åŠ è½½å¿…è¦çš„åº“ -->
    <script src="lib/idb.js"></script>
    <script src="lib/error-handler.js"></script>
    <script src="lib/error-ui.js"></script>
    <script src="lib/mimir-db.js"></script>
    <script src="lib/db-wrapper.js"></script>
    <script src="lib/migration.js"></script>

    <script>
        function log(section, message, type = 'info') {
            const resultsDiv = document.getElementById(section + 'Results');
            const timestamp = new Date().toLocaleTimeString();
            const statusClass = type === 'error' ? 'error' : type === 'warning' ? 'warning' : type === 'success' ? 'success' : 'info';
            
            resultsDiv.innerHTML += `<div><span class="status-indicator ${statusClass}"></span>[${timestamp}] ${message}</div>`;
            resultsDiv.scrollTop = resultsDiv.scrollHeight;
        }

        function updateProgress(percent, text) {
            const progressBar = document.getElementById('backupProgress');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            
            if (percent > 0) {
                progressBar.style.display = 'block';
                progressText.style.display = 'block';
                progressFill.style.width = percent + '%';
                progressText.textContent = text || `è¿›åº¦: ${percent}%`;
            } else {
                progressBar.style.display = 'none';
                progressText.style.display = 'none';
            }
        }

        // å†å²è®°å½•ç»Ÿè®¡
        async function checkHistoryStats() {
            try {
                log('stats', 'æ­£åœ¨æ£€æŸ¥å†å²è®°å½•ç»Ÿè®¡...', 'info');
                
                // è·å–æµè§ˆå™¨å†å²è®°å½•æ•°é‡
                const browserHistory = await chrome.history.search({
                    text: '',
                    maxResults: 0
                });
                
                // è·å–å¤‡ä»½çŠ¶æ€
                const backupStatus = await new Promise((resolve) => {
                    chrome.runtime.sendMessage({ action: 'getBackupStatus' }, resolve);
                });
                
                if (backupStatus.success) {
                    const browserCount = backupStatus.browserHistoryCount;
                    const backedUpCount = backupStatus.totalBackedUpRecords;
                    const coverage = backupStatus.backupCoverage;
                    const missing = browserCount - backedUpCount;
                    
                    // æ›´æ–°ç»Ÿè®¡å¡ç‰‡
                    document.getElementById('browserHistoryCount').textContent = browserCount.toLocaleString();
                    document.getElementById('backedUpCount').textContent = backedUpCount.toLocaleString();
                    document.getElementById('coveragePercent').textContent = coverage + '%';
                    document.getElementById('missingCount').textContent = Math.max(0, missing).toLocaleString();
                    
                    log('stats', `âœ“ æµè§ˆå™¨å†å²è®°å½•: ${browserCount.toLocaleString()} æ¡`, 'success');
                    log('stats', `âœ“ å·²å¤‡ä»½è®°å½•: ${backedUpCount.toLocaleString()} æ¡`, 'success');
                    log('stats', `âœ“ å¤‡ä»½è¦†ç›–ç‡: ${coverage}%`, coverage >= 90 ? 'success' : coverage >= 70 ? 'warning' : 'error');
                    log('stats', `âœ“ æœªå¤‡ä»½è®°å½•: ${Math.max(0, missing).toLocaleString()} æ¡`, missing > 0 ? 'warning' : 'success');
                    
                    if (missing > 0) {
                        log('stats', 'âš  å»ºè®®è¿›è¡Œå®Œæ•´å¤‡ä»½ä»¥å¤‡ä»½æ‰€æœ‰å†å²è®°å½•', 'warning');
                    }
                } else {
                    log('stats', `âœ— è·å–å¤‡ä»½çŠ¶æ€å¤±è´¥: ${backupStatus.error}`, 'error');
                }
                
            } catch (error) {
                log('stats', `âœ— æ£€æŸ¥ç»Ÿè®¡å¤±è´¥: ${error.message}`, 'error');
            }
        }

        async function analyzeHistoryGaps() {
            try {
                log('stats', 'æ­£åœ¨åˆ†æå¤‡ä»½ç¼ºå£...', 'info');
                
                // è·å–æœ€è¿‘1000æ¡æµè§ˆå™¨å†å²è®°å½•è¿›è¡Œé‡‡æ ·åˆ†æ
                const recentHistory = await chrome.history.search({
                    text: '',
                    maxResults: 1000
                });
                
                // è·å–IndexedDBä¸­çš„å†å²è®°å½•
                const db = new MimirDB();
                await db.initialize();
                const backedUpHistory = await db.getAllHistory();
                
                // åˆ›å»ºå¤‡ä»½è®°å½•çš„URL-æ—¶é—´æˆ³æ˜ å°„
                const backedUpMap = new Set();
                backedUpHistory.forEach(record => {
                    backedUpMap.add(`${record.url}-${record.timestamp}`);
                });
                
                // åˆ†æç¼ºå£
                let missingCount = 0;
                let oldestMissing = null;
                let newestMissing = null;
                
                recentHistory.forEach(item => {
                    const key = `${item.url}-${item.lastVisitTime}`;
                    if (!backedUpMap.has(key)) {
                        missingCount++;
                        if (!oldestMissing || item.lastVisitTime < oldestMissing) {
                            oldestMissing = item.lastVisitTime;
                        }
                        if (!newestMissing || item.lastVisitTime > newestMissing) {
                            newestMissing = item.lastVisitTime;
                        }
                    }
                });
                
                log('stats', `âœ“ é‡‡æ ·åˆ†æå®Œæˆï¼ˆæœ€è¿‘1000æ¡è®°å½•ï¼‰`, 'success');
                log('stats', `âœ“ å‘ç°ç¼ºå¤±è®°å½•: ${missingCount} æ¡`, missingCount > 0 ? 'warning' : 'success');
                
                if (missingCount > 0) {
                    log('stats', `âœ“ æœ€æ—©ç¼ºå¤±æ—¶é—´: ${new Date(oldestMissing).toLocaleString()}`, 'info');
                    log('stats', `âœ“ æœ€æ–°ç¼ºå¤±æ—¶é—´: ${new Date(newestMissing).toLocaleString()}`, 'info');
                    log('stats', `âš  å»ºè®®è¿›è¡Œå®Œæ•´å¤‡ä»½ä»¥å¡«è¡¥ç¼ºå£`, 'warning');
                }
                
            } catch (error) {
                log('stats', `âœ— åˆ†æç¼ºå£å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // å¤‡ä»½åŠŸèƒ½æµ‹è¯•
        async function testIncrementalBackup() {
            try {
                const btn = document.getElementById('incrementalBtn');
                btn.disabled = true;
                btn.textContent = 'ğŸ’¾ å¢é‡å¤‡ä»½ä¸­...';
                
                log('backup', 'å¼€å§‹å¢é‡å¤‡ä»½æµ‹è¯•...', 'info');
                updateProgress(10, 'æ­£åœ¨å¯åŠ¨å¢é‡å¤‡ä»½...');
                
                const startTime = Date.now();
                const result = await new Promise((resolve) => {
                    chrome.runtime.sendMessage({ action: 'backupHistory' }, resolve);
                });
                
                const duration = Date.now() - startTime;
                updateProgress(0);
                
                if (result.success) {
                    log('backup', `âœ“ å¢é‡å¤‡ä»½æˆåŠŸ: ${result.message}`, 'success');
                    log('backup', `âœ“ å¤‡ä»½è€—æ—¶: ${(duration/1000).toFixed(2)} ç§’`, 'success');
                    log('backup', `âœ“ å¤„ç†è®°å½•: ${result.totalRecords} æ¡`, 'info');
                    log('backup', `âœ“ æ–°å¢å¤‡ä»½: ${result.backedUpRecords} æ¡`, 'success');
                    
                    // åˆ·æ–°ç»Ÿè®¡
                    await checkHistoryStats();
                } else {
                    log('backup', `âœ— å¢é‡å¤‡ä»½å¤±è´¥: ${result.error}`, 'error');
                }
                
            } catch (error) {
                log('backup', `âœ— å¢é‡å¤‡ä»½æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                updateProgress(0);
            } finally {
                const btn = document.getElementById('incrementalBtn');
                btn.disabled = false;
                btn.textContent = 'ğŸ’¾ æµ‹è¯•å¢é‡å¤‡ä»½';
            }
        }

        async function testFullBackup() {
            const confirmed = confirm('è­¦å‘Šï¼šå®Œæ•´å¤‡ä»½å°†å¤„ç†æ‰€æœ‰å†å²è®°å½•ï¼\n\nå¯¹äºå¤§é‡è®°å½•ï¼ˆå¦‚10000+æ¡ï¼‰ï¼Œè¿™å¯èƒ½éœ€è¦10-20åˆ†é’Ÿæ—¶é—´ã€‚\nç¡®å®šè¦ç»§ç»­å—ï¼Ÿ');
            if (!confirmed) return;
            
            try {
                const btn = document.getElementById('fullBackupBtn');
                btn.disabled = true;
                btn.textContent = 'ğŸ”„ å®Œæ•´å¤‡ä»½ä¸­...';
                
                log('backup', 'å¼€å§‹å®Œæ•´å¤‡ä»½æµ‹è¯•ï¼ˆè¯·è€å¿ƒç­‰å¾…ï¼‰...', 'warning');
                updateProgress(5, 'æ­£åœ¨å¯åŠ¨å®Œæ•´å¤‡ä»½...');
                
                const startTime = Date.now();
                
                // æ¨¡æ‹Ÿè¿›åº¦æ›´æ–°
                const progressInterval = setInterval(() => {
                    const elapsed = Date.now() - startTime;
                    const estimatedTotal = 600000; // é¢„ä¼°10åˆ†é’Ÿ
                    const progress = Math.min(90, (elapsed / estimatedTotal) * 100);
                    updateProgress(progress, `å®Œæ•´å¤‡ä»½è¿›è¡Œä¸­... ${Math.round(progress)}%`);
                }, 2000);
                
                const result = await new Promise((resolve) => {
                    chrome.runtime.sendMessage({ action: 'fullBackupHistory' }, resolve);
                });
                
                clearInterval(progressInterval);
                const duration = Date.now() - startTime;
                updateProgress(100, 'å®Œæ•´å¤‡ä»½å®Œæˆï¼');
                
                setTimeout(() => updateProgress(0), 3000);
                
                if (result.success) {
                    log('backup', `âœ“ å®Œæ•´å¤‡ä»½æˆåŠŸ: ${result.message}`, 'success');
                    log('backup', `âœ“ å¤‡ä»½è€—æ—¶: ${(duration/1000/60).toFixed(2)} åˆ†é’Ÿ`, 'success');
                    log('backup', `âœ“ å¤„ç†è®°å½•: ${result.totalRecords} æ¡`, 'info');
                    log('backup', `âœ“ æ–°å¢å¤‡ä»½: ${result.backedUpRecords} æ¡`, 'success');
                    log('backup', `âœ“ è·³è¿‡é‡å¤: ${result.skippedRecords} æ¡`, 'info');
                    
                    // åˆ·æ–°ç»Ÿè®¡
                    await checkHistoryStats();
                } else {
                    log('backup', `âœ— å®Œæ•´å¤‡ä»½å¤±è´¥: ${result.error}`, 'error');
                }
                
            } catch (error) {
                log('backup', `âœ— å®Œæ•´å¤‡ä»½æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                updateProgress(0);
            } finally {
                const btn = document.getElementById('fullBackupBtn');
                btn.disabled = false;
                btn.textContent = 'ğŸ”„ æµ‹è¯•å®Œæ•´å¤‡ä»½ï¼ˆæ…ç”¨ï¼‰';
            }
        }

        async function testBackupStatus() {
            try {
                log('backup', 'æ£€æŸ¥è¯¦ç»†å¤‡ä»½çŠ¶æ€...', 'info');
                
                const status = await new Promise((resolve) => {
                    chrome.runtime.sendMessage({ action: 'getBackupStatus' }, resolve);
                });
                
                if (status.success) {
                    log('backup', `âœ“ å¤‡ä»½çŠ¶æ€: æ­£å¸¸`, 'success');
                    log('backup', `âœ“ æœ€åå¤‡ä»½: ${status.lastBackupDate}`, 'info');
                    log('backup', `âœ“ å¤‡ä»½è®°å½•æ•°: ${status.totalBackedUpRecords.toLocaleString()}`, 'success');
                    log('backup', `âœ“ æµè§ˆå™¨è®°å½•æ•°: ${status.browserHistoryCount.toLocaleString()}`, 'info');
                    log('backup', `âœ“ å¤‡ä»½è¦†ç›–ç‡: ${status.backupCoverage}%`, 'success');
                    
                    if (status.needsFullBackup) {
                        log('backup', 'âš  å»ºè®®è¿›è¡Œå®Œæ•´å¤‡ä»½', 'warning');
                    }
                    
                    if (status.lastBackupStats) {
                        const stats = status.lastBackupStats;
                        log('backup', `âœ“ ä¸Šæ¬¡å¤‡ä»½ç»Ÿè®¡: å¤„ç†${stats.totalProcessed}æ¡ï¼ŒæˆåŠŸ${stats.successCount}æ¡ï¼Œè·³è¿‡${stats.skippedCount}æ¡`, 'info');
                    }
                } else {
                    log('backup', `âœ— è·å–å¤‡ä»½çŠ¶æ€å¤±è´¥: ${status.error}`, 'error');
                }
                
            } catch (error) {
                log('backup', `âœ— æ£€æŸ¥å¤‡ä»½çŠ¶æ€å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æ€§èƒ½æµ‹è¯•
        async function testBatchProcessing() {
            try {
                log('performance', 'æµ‹è¯•æ‰¹é‡å¤„ç†æ€§èƒ½...', 'info');
                
                const startTime = Date.now();
                
                // è·å–1000æ¡å†å²è®°å½•è¿›è¡Œæ€§èƒ½æµ‹è¯•
                const testHistory = await chrome.history.search({
                    text: '',
                    maxResults: 1000
                });
                
                const fetchTime = Date.now() - startTime;
                log('performance', `âœ“ è·å–1000æ¡è®°å½•è€—æ—¶: ${fetchTime}ms`, 'success');
                
                // æµ‹è¯•æ•°æ®å¤„ç†æ€§èƒ½
                const processStart = Date.now();
                let processedCount = 0;
                
                for (const item of testHistory) {
                    // æ¨¡æ‹Ÿæ•°æ®å¤„ç†
                    const processed = {
                        timestamp: item.lastVisitTime,
                        date: new Date(item.lastVisitTime).toISOString().split('T')[0],
                        url: item.url,
                        title: item.title,
                        domain: new URL(item.url).hostname,
                        visitCount: item.visitCount || 1
                    };
                    processedCount++;
                }
                
                const processTime = Date.now() - processStart;
                log('performance', `âœ“ å¤„ç†${processedCount}æ¡è®°å½•è€—æ—¶: ${processTime}ms`, 'success');
                log('performance', `âœ“ å¹³å‡å¤„ç†é€Ÿåº¦: ${(processedCount/processTime*1000).toFixed(0)} æ¡/ç§’`, 'success');
                
                // ä¼°ç®—å®Œæ•´å¤‡ä»½æ—¶é—´
                const estimatedFullTime = (processTime / 1000) * (10793 / 1000);
                log('performance', `âœ“ é¢„ä¼°å¤„ç†10793æ¡è®°å½•éœ€è¦: ${estimatedFullTime.toFixed(1)} ç§’`, 'info');
                
            } catch (error) {
                log('performance', `âœ— æ€§èƒ½æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        async function testDatabaseQuery() {
            try {
                log('performance', 'æµ‹è¯•æ•°æ®åº“æŸ¥è¯¢æ€§èƒ½...', 'info');
                
                const db = new MimirDB();
                await db.initialize();
                
                // æµ‹è¯•æŸ¥è¯¢æ‰€æœ‰è®°å½•
                const queryStart = Date.now();
                const allRecords = await db.getAllHistory();
                const queryTime = Date.now() - queryStart;
                
                log('performance', `âœ“ æŸ¥è¯¢${allRecords.length}æ¡è®°å½•è€—æ—¶: ${queryTime}ms`, 'success');
                
                if (allRecords.length > 0) {
                    // æµ‹è¯•æŒ‰æ—¥æœŸèŒƒå›´æŸ¥è¯¢
                    const rangeStart = Date.now();
                    const today = new Date().toISOString().split('T')[0];
                    const weekAgo = new Date(Date.now() - 7*24*60*60*1000).toISOString().split('T')[0];
                    
                    const rangeRecords = await db.getHistoryByDateRange(weekAgo, today);
                    const rangeTime = Date.now() - rangeStart;
                    
                    log('performance', `âœ“ æŒ‰æ—¥æœŸèŒƒå›´æŸ¥è¯¢${rangeRecords.length}æ¡è®°å½•è€—æ—¶: ${rangeTime}ms`, 'success');
                }
                
            } catch (error) {
                log('performance', `âœ— æ•°æ®åº“æŸ¥è¯¢æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        async function testMemoryUsage() {
            try {
                log('performance', 'æµ‹è¯•å†…å­˜ä½¿ç”¨æƒ…å†µ...', 'info');
                
                if (performance.memory) {
                    const memory = performance.memory;
                    log('performance', `âœ“ å·²ä½¿ç”¨å†…å­˜: ${(memory.usedJSHeapSize/1024/1024).toFixed(2)} MB`, 'info');
                    log('performance', `âœ“ æ€»åˆ†é…å†…å­˜: ${(memory.totalJSHeapSize/1024/1024).toFixed(2)} MB`, 'info');
                    log('performance', `âœ“ å†…å­˜é™åˆ¶: ${(memory.jsHeapSizeLimit/1024/1024).toFixed(2)} MB`, 'info');
                    
                    const usagePercent = (memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100;
                    log('performance', `âœ“ å†…å­˜ä½¿ç”¨ç‡: ${usagePercent.toFixed(1)}%`, usagePercent > 80 ? 'warning' : 'success');
                } else {
                    log('performance', 'âš  æµè§ˆå™¨ä¸æ”¯æŒå†…å­˜ç›‘æ§API', 'warning');
                }
                
            } catch (error) {
                log('performance', `âœ— å†…å­˜æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æ•°æ®éªŒè¯
        async function validateBackupData() {
            try {
                log('validation', 'éªŒè¯å¤‡ä»½æ•°æ®å®Œæ•´æ€§...', 'info');
                
                const db = new MimirDB();
                await db.initialize();
                const backedUpRecords = await db.getAllHistory();
                
                log('validation', `âœ“ æ‰¾åˆ° ${backedUpRecords.length} æ¡å¤‡ä»½è®°å½•`, 'success');
                
                // éªŒè¯æ•°æ®ç»“æ„
                let validCount = 0;
                let invalidCount = 0;
                
                for (const record of backedUpRecords.slice(0, 100)) { // éªŒè¯å‰100æ¡
                    if (record.url && record.title && record.timestamp && record.domain) {
                        validCount++;
                    } else {
                        invalidCount++;
                    }
                }
                
                log('validation', `âœ“ æ•°æ®ç»“æ„éªŒè¯: ${validCount} æ¡æœ‰æ•ˆï¼Œ${invalidCount} æ¡æ— æ•ˆ`, invalidCount > 0 ? 'warning' : 'success');
                
                // éªŒè¯æ—¶é—´æˆ³
                const sortedRecords = backedUpRecords.sort((a, b) => b.timestamp - a.timestamp);
                if (sortedRecords.length > 0) {
                    const newest = new Date(sortedRecords[0].timestamp);
                    const oldest = new Date(sortedRecords[sortedRecords.length - 1].timestamp);
                    
                    log('validation', `âœ“ æ—¶é—´èŒƒå›´: ${oldest.toLocaleDateString()} åˆ° ${newest.toLocaleDateString()}`, 'success');
                }
                
            } catch (error) {
                log('validation', `âœ— æ•°æ®éªŒè¯å¤±è´¥: ${error.message}`, 'error');
            }
        }

        async function compareWithBrowser() {
            try {
                log('validation', 'ä¸æµè§ˆå™¨æ•°æ®å¯¹æ¯”...', 'info');
                
                // è·å–æœ€è¿‘100æ¡æµè§ˆå™¨è®°å½•è¿›è¡Œå¯¹æ¯”
                const browserRecords = await chrome.history.search({
                    text: '',
                    maxResults: 100
                });
                
                const db = new MimirDB();
                await db.initialize();
                const backedUpRecords = await db.getAllHistory();
                
                // åˆ›å»ºå¤‡ä»½è®°å½•æ˜ å°„
                const backupMap = new Map();
                backedUpRecords.forEach(record => {
                    backupMap.set(`${record.url}-${record.timestamp}`, record);
                });
                
                let matchCount = 0;
                let mismatchCount = 0;
                
                for (const browserRecord of browserRecords) {
                    const key = `${browserRecord.url}-${browserRecord.lastVisitTime}`;
                    if (backupMap.has(key)) {
                        matchCount++;
                    } else {
                        mismatchCount++;
                    }
                }
                
                log('validation', `âœ“ å¯¹æ¯”ç»“æœ: ${matchCount} æ¡åŒ¹é…ï¼Œ${mismatchCount} æ¡ä¸åŒ¹é…`, 'success');
                log('validation', `âœ“ åŒ¹é…ç‡: ${(matchCount/(matchCount+mismatchCount)*100).toFixed(1)}%`, 'success');
                
            } catch (error) {
                log('validation', `âœ— æ•°æ®å¯¹æ¯”å¤±è´¥: ${error.message}`, 'error');
            }
        }

        async function checkDataConsistency() {
            try {
                log('validation', 'æ£€æŸ¥æ•°æ®ä¸€è‡´æ€§...', 'info');
                
                const db = new MimirDB();
                await db.initialize();
                const records = await db.getAllHistory();
                
                // æ£€æŸ¥é‡å¤è®°å½•
                const urlTimestampSet = new Set();
                let duplicateCount = 0;
                
                records.forEach(record => {
                    const key = `${record.url}-${record.timestamp}`;
                    if (urlTimestampSet.has(key)) {
                        duplicateCount++;
                    } else {
                        urlTimestampSet.add(key);
                    }
                });
                
                log('validation', `âœ“ é‡å¤è®°å½•æ£€æŸ¥: å‘ç° ${duplicateCount} æ¡é‡å¤è®°å½•`, duplicateCount > 0 ? 'warning' : 'success');
                
                // æ£€æŸ¥æ•°æ®å®Œæ•´æ€§
                let incompleteCount = 0;
                records.slice(0, 1000).forEach(record => { // æ£€æŸ¥å‰1000æ¡
                    if (!record.url || !record.title || !record.timestamp) {
                        incompleteCount++;
                    }
                });
                
                log('validation', `âœ“ æ•°æ®å®Œæ•´æ€§æ£€æŸ¥: å‘ç° ${incompleteCount} æ¡ä¸å®Œæ•´è®°å½•`, incompleteCount > 0 ? 'warning' : 'success');
                
            } catch (error) {
                log('validation', `âœ— ä¸€è‡´æ€§æ£€æŸ¥å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        window.addEventListener('load', () => {
            log('stats', 'å¤§é‡å†å²è®°å½•å¤‡ä»½æµ‹è¯•é¡µé¢å·²åŠ è½½', 'success');
            log('backup', 'å¤‡ä»½åŠŸèƒ½æµ‹è¯•å‡†å¤‡å°±ç»ª', 'success');
            log('performance', 'æ€§èƒ½æµ‹è¯•å‡†å¤‡å°±ç»ª', 'success');
            log('validation', 'æ•°æ®éªŒè¯æµ‹è¯•å‡†å¤‡å°±ç»ª', 'success');
            
            // è‡ªåŠ¨æ£€æŸ¥ç»Ÿè®¡
            checkHistoryStats();
        });
    </script>
</body>
</html>